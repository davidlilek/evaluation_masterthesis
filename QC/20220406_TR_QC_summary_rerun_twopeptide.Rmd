---
title: "DataAnalysis - Postprocessing Results MaxQuant"
autor: David Lilek
date: "`r format(Sys.time(), '%d %B %Y, %X')`"
output:
  html_document:
    df_print: paged
    fig.align: center
    self_contained: yes
    fig.height: 4
    fig.width: 8
    theme: united
    toc: yes
    toc_depth: 4
    toc_float: yes
    number_sections: yes
    code_folding: hide
---

```{r start, message=FALSE, warning=FALSE, include=FALSE}
start_time = format(Sys.time(), '%X')
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
#load libraries
library(tidyverse)
library(dplyr)
library(gplots)
library(reshape2) #for melting data for boxplot with ggplot
library(pheatmap)
library(MASS)
library(ggpubr)
```


```{r results="asis"}
###############################
#
#define settings
#
###############################

path = "N:/1_A_Bachelor_Master_Intern/00_M_2022/David/Data/evaluation_masterthesis/QC/tmpfiles/qc_twouniquepeptide/"

##########read in all data with pattern .txt
# get file list
file.list <- list.files(path = path, pattern='*.csv')
# create file path
file.path <- paste(path,file.list,sep = "")
# read in files - for each file one variable is created - results are stored in a list
res_raw <- lapply(file.path, function(i){read.csv2(i, row.names = 1)})
names(res_raw) <- file.list
```

```{r}
#create data.frame
res<-as.data.frame(res_raw)
rownames(res) <- NULL
```

```{r}
#functions
CV <- function(x){
  (sd(x)/mean(x))*100
}

MEAN <- function(x){
  mean(x)
}
```


# Razor

```{r}
razor <- res[,grep("Razor",colnames(res))]
colnames(razor) <- c("MBR_pooled","MBR_pooled\noldversion","MBR","noMBR_pooled","noMBR_pooled\noldversion","noMBR")
boxplot(razor)
apply(razor,2,CV)
```

# Unique

```{r}
unique <- res[,grep("Unique",colnames(res))]
colnames(unique) <- c("MBR_pooled","MBR_pooled\noldversion","MBR","noMBR_pooled","noMBR_pooled\noldversion","noMBR")
boxplot(unique)
apply(unique,2,CV)
```
# LFQ

```{r}
lfq <- res[,grep("LFQ",colnames(res))]
colnames(lfq) <- c("MBR_pooled","MBR_pooled\noldversion","MBR","noMBR_pooled","noMBR_pooled\noldversion","noMBR")
boxplot(lfq)
apply(lfq,2,CV)
```

# visualize no protein identifications

```{r}
#plot data
no <- c(apply(razor,2,MEAN),apply(unique,2,MEAN),apply(lfq,2,MEAN))

evaluation <- rep(c("MBR_pooled","MBR_pooled_oldversion","MBR","noMBR_pooled","noMBR_pooled_oldversion","noMBR"),3)

type <- c("Razor","Unique","LFQ")
type <- rep(type, each=6)

df <- data.frame(no, type, evaluation)
colnames(df) <- c("no","Type","Evaluation")

#reorder x axis
df$Type <- factor(df$Type,
                  levels = c("Razor","Unique","LFQ"))
df$Evaluation <- factor(df$Evaluation,
                               levels = c("MBR_pooled","MBR_pooled_oldversion","MBR","noMBR_pooled","noMBR_pooled_oldversion","noMBR"))

p_plot_two <- ggplot(df, aes(x=Type, y=no, fill=Evaluation)) +
    geom_bar(stat='identity', position='dodge') +
  theme_minimal() +
  scale_fill_brewer(palette="Dark2") +
  theme(legend.position="bottom") +
  theme(legend.key.size = unit(0.15, 'cm')) +
  guides(fill=guide_legend(nrow=2, byrow=TRUE)) +
  ylab("No. of protein identifications") +
  labs(fill = "Evaluation \n method") 
  # scale_y_break(c(100,1200)) with library(ggbreak)
p_plot_two
```


* type of Razor peptides: `r df$Evaluation[df$Type=="Razor"]`
* mean of Razor peptides: `r df$no[df$Type=="Razor"]`
* type of unique peptides: `r df$Evaluation[df$Type=="Unique"]`
* mean of unique peptides: `r df$no[df$Type=="Unique"]`
* type of lfq peptides: `r df$Evaluation[df$Type=="LFQ"]`
* mean of lfq peptides: `r df$no[df$Type=="LFQ"]`

Using at least two razor&unique resp unique peptide as treshhold for the data analysis it can be seen that the number of protein identifications is quite similar for type Razor and Unique independet which evaluation method is used. For LFQ the number of protein identifications is higher than for Razor resp Unique but depends on the used evaluation method. 
Taking a closer look it can be seen that be seen that for Razor and Unique app. 6 resp 10 more proteins could be found with the newer version of MaxQuant (evaluation method MBR_pooled resp noMBR_pooled). For LFQ the option one or two razor&unique resp unique has no influence on the number and protein identification and rsd.
Pooling the samples after protein identification/quantification manually (MBR resp no_MBR) leads to a lower number of protein identifications (40 for MBR, 55 for no_MBR using Razor or Unique). The evaluation method MBR didn't increase or decrease the number of protein idenitification significantly using type Razor and Unique. 


# visualize rsd

```{r}
#plot data
rsd <- c(apply(razor,2,CV),apply(unique,2,CV),apply(lfq,2,CV))

evaluation <- rep(c("MBR_pooled","MBR_pooled_oldversion","MBR","noMBR_pooled","noMBR_pooled_oldversion","noMBR"),3)

type <- c("Razor","Unique","LFQ")
type <- rep(type, each=6)

df <- data.frame(no, rsd, type, evaluation)
colnames(df) <- c("no","rsd","Type","Evaluation")

#reorder x axis
df$Type <- factor(df$Type,
                  levels = c("Razor","Unique","LFQ"))
df$Evaluation <- factor(df$Evaluation,
                               levels = c("MBR_pooled","MBR_pooled_oldversion","MBR","noMBR_pooled","noMBR_pooled_oldversion","noMBR"))

rsd_plot_two <- ggplot(df, aes(x=Type, y=rsd, fill=Evaluation)) +
    geom_bar(stat='identity', position='dodge') +
  theme_minimal() +
  scale_fill_brewer(palette="Dark2") +
  theme(legend.position="bottom") +
  theme(legend.key.size = unit(0.15, 'cm')) +
  guides(fill=guide_legend(nrow=2, byrow=TRUE)) +
  ylab("relative sd [%]") +
  labs(fill = "Evaluation \n method")
rsd_plot_two
```

The relative standard deviation (rsd) depends strongly on the used evualation method. Especially using the old version leads to significant higher rsd than the newer version inpdendet if MBR is used or not. The lowest rsd could be achieved using pooling during protein identification/quantification (MBR_pooled) follwed by noMBR, noMBR_pooled and MBR independet which type was used. So no clear results could be made as to whether manual pooling or pooling during protein identification/quantification provides the lower rsd.

# CONCLUSION one and two peptides

Using at least two razor&unique resp unique peptide as treshhold for the data analysis decreases the number of protein identifications and increases the rsd. MBR has no significant influence on the number of protein identification.

```{r}
df_onepeptide <- readRDS("20220406_TR_QC_summary_rerun_onepeptide.rds")
t <- df_onepeptide$no[-c(13:18)]/df$no[-c(13:18)]
tt <- (1-t[1:12])*100
t_sd <- df_onepeptide$rsd/df$rsd
tt_sd <- (t[1:12]-1)*100
df_comp <- as.data.frame(cbind(tt,tt_sd))
colnames(df_comp) <- c("Protein identification","rsd")
boxplot(df_comp$`Protein identification`, df_comp$rsd, ylab ="Deviation one peptide vs two peptides [%]", names = colnames(df_comp))
```
# LaTeX

```{r}
knitr::kable(df, booktabs = T, "latex")
```



# Used time

```{r end, message=FALSE, warning=FALSE, include=FALSE}
end_time = format(Sys.time(), '%X')
```



```{r used time, echo=FALSE, message=TRUE, warning=FALSE}
print(paste("Time used for analysis:", round(as.difftime(end_time, units = "mins")-as.difftime(start_time, units = "mins"),digits=2),"minutes"))
```
